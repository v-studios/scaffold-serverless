
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>Scaffolding Serverless 0.1 documentation</title>
    <link rel="stylesheet" href="_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '0.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head>
  <body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="a-scaffolding-for-serverless">
<h1>A Scaffolding for Serverless<a class="headerlink" href="#a-scaffolding-for-serverless" title="Permalink to this headline">¶</a></h1>
<div class="toctree-wrapper compound">
<span id="document-docs"></span><div class="section" id="docs">
<h2>Docs<a class="headerlink" href="#docs" title="Permalink to this headline">¶</a></h2>
<p>We use <a class="reference external" href="http://www.sphinx-doc.org/en/stable/index.html">Sphinx</a> for
documentation, and it’s written in Python, so we’ll setup a Python
virtual environment.</p>
<div class="section" id="install">
<h3>Install<a class="headerlink" href="#install" title="Permalink to this headline">¶</a></h3>
<p>If you are using <a class="reference external" href="https://github.com/pyenv/pyenv">pyenv</a> to manage
python versions, pick a python3 like:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">pyenv</span> <span class="n">local</span> <span class="mf">3.6</span><span class="o">.</span><span class="mi">3</span>
</pre></div>
</div>
<p>Create a virtual environment:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">virtualenv</span> <span class="o">--</span><span class="n">python</span><span class="o">=</span><span class="n">python3</span> <span class="o">.</span><span class="n">venv3</span>
</pre></div>
</div>
<p>Activate your virtual environment:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">source</span> <span class="o">.</span><span class="n">venv3</span><span class="o">/</span><span class="nb">bin</span><span class="o">/</span><span class="n">activate</span>
</pre></div>
</div>
<p>I manually installed Sphinx, then created a requirements
<a class="reference external" href="requirements.txt">requirements.txt</a> file so you don’t have install it; instead,
install all the listed and versioned dependencies:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">pip</span> <span class="n">install</span> <span class="o">-</span><span class="n">r</span> <span class="n">requirements</span><span class="o">.</span><span class="n">txt</span>
</pre></div>
</div>
<p>Then I ran the quickstart and took the defaults, except I used
<code class="docutils literal"><span class="pre">docs</span></code> as my root path, and gave it my name and version number:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">sphinx</span><span class="o">-</span><span class="n">quickstart</span>
</pre></div>
</div>
<p>You won’t have to run the quickstart, everything’s in <code class="docutils literal"><span class="pre">docs</span></code>.</p>
</div>
<div class="section" id="building-docs">
<h3>Building Docs<a class="headerlink" href="#building-docs" title="Permalink to this headline">¶</a></h3>
<p>To do it manually, you can build the docs by going into the <code class="docutils literal"><span class="pre">docs</span></code>
directory (with virtualenv activated) and use its Makefile to create a
HTML version:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">cd</span> <span class="n">docs</span>
<span class="n">make</span> <span class="n">html</span>
</pre></div>
</div>
<p>Then you can open up the <a class="reference external" href="_build/html/index.html">_build/html/index.html</a> file and see your beautiful docs. Ta da!</p>
<p>That creates standalone html files, but you can make a single large HTML with:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">make</span> <span class="n">singlehtml</span>
</pre></div>
</div>
<p>whose output is in <a class="reference external" href="_build/singlehtml/index.html">_build/singlehtml/index.html</a>.</p>
<p>You can even make ePub with:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">make</span> <span class="n">epub</span>
</pre></div>
</div>
<p>and find the output in <a class="reference external" href="_build/epub/ScaffoldingServerless.epub">_build/epub/ScaffoldingServerless.epub</a>.</p>
<p>As a convenience (with virtualenv activated), in the top level
directory, you can build all versions:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">make</span> <span class="n">docs</span>
</pre></div>
</div>
</div>
<div class="section" id="editing-docs">
<h3>Editing Docs<a class="headerlink" href="#editing-docs" title="Permalink to this headline">¶</a></h3>
<p>Edit the RST pages, as you wish, rebuild, and commit your builds if
you wish. If you add a new page, reference it from the <a class="reference external" href="index.rst">index.rst</a> file, omitting the <code class="docutils literal"><span class="pre">.rst</span></code> extension.</p>
<p>Syntax and Configuration (in <code class="docutils literal"><span class="pre">conf.py</span></code> are beyond the scope of this doc).</p>
</div>
</div>
<span id="document-testing"></span><div class="section" id="testing">
<h2>Testing<a class="headerlink" href="#testing" title="Permalink to this headline">¶</a></h2>
<p>We prefer <a class="reference external" href="https://docs.pytest.org/en/latest/">pytest</a> to the
built-in unit tests as they’re shorter to write and have more
capabilities.  It’s installed as part of the <a class="reference external" href="requirements.txt">requirements.txt</a> file.</p>
<p>You should write your tests, organized into different <code class="docutils literal"><span class="pre">test_\*.py</span></code>
or <code class="docutils literal"><span class="pre">*_test.py</span></code> files under the <code class="docutils literal"><span class="pre">tests/</span></code> directory.  For example,
you might have <code class="docutils literal"><span class="pre">test_apig.py</span></code>, <code class="docutils literal"><span class="pre">test_dynamodb.py</span></code>,
<code class="docutils literal"><span class="pre">test_authentication.py</span></code> and so on.  You can use this for unit tests
or integration tests.</p>
<p>For info on writing tests, see the <cite>pytest</cite> docs.</p>
<p>To run the tests, with virtualenv activated, in the top level
directory, do:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">make</span> <span class="n">tests</span>
</pre></div>
</div>
<p>We also installed <code class="docutils literal"><span class="pre">pytest-cov</span></code> to measure code test coverage. You
can run that with:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">make</span> <span class="n">coverage</span>
</pre></div>
</div>
<p>It’s settings are configured in <code class="docutils literal"><span class="pre">.coveragerc</span></code>.  It stores state
information in <code class="docutils literal"><span class="pre">.coverage</span></code> and output a HTML report under
<code class="docutils literal"><span class="pre">htmlcov/</span></code>; don’t check these into source control (these are
gitignored here).</p>
</div>
<span id="document-cicd"></span><div class="section" id="ci-cd">
<h2>CI/CD<a class="headerlink" href="#ci-cd" title="Permalink to this headline">¶</a></h2>
<p>Continuous Integration / Continuous Deployment helps find bugs faster
and helps prevent bad code from getting out into the world.</p>
<p>We use commercial SaaS <a class="reference external" href="https://circleci.com/">CircleCI</a> as it’s
reasonably priced, pretty easy to use, and featureful with good
integrations into GitHub, AWS, etc.</p>
<p>To create a new “project”, login to CircleCI with your GitHub
credentials, select your group from the list of GitHub groups you
belong to(e.g., v-studios) from the top left pulldown, then click into
PROJECTS on the left nav bar. Add Project from the top right: it will
list your GitHub repos. I picked “scaffold-serverless”, strangely
enough, and select “Setup project”.</p>
<p>Next pick Operating System “Linux” and Language “Python”</p>
<p>TODO: we have to pick a different language container for Serverless,
because we need Node and Python; I’m trying Node this time to see if
it might have python.</p>
<p>I followed the directions to create a .circleci/config.yml file and
then started to populate it.</p>
<p>I’ll first make it create a virtualenv, pip install the requirements,
then run the tests.  It should test our (serverless) python code.</p>
<p>Later, I’ll add a workflow step that deploys the serverless app to our
AWS “stage” (feature-branch, dev, qa, prod). Then run integration tests.</p>
<p>Instead of hard-coding all the virtualenv and pytest command line goo
in the CircleCI config, we use targets in the Makefile. That way, we
can give the developer easy “make …” commands that are identical to
what the CI system uses.</p>
<p>When you commit and push – to any branch – CircleCI will build. You
can check the status on the <a class="reference external" href="https://circleci.com/gh/v-studios/scaffold-serverless">CircleCI Dashboard</a>.</p>
<div class="section" id="deploy-serverless-app-to-multiple-stage-environments">
<h3>Deploy Serverless App to Multiple Stage Environments<a class="headerlink" href="#deploy-serverless-app-to-multiple-stage-environments" title="Permalink to this headline">¶</a></h3>
<p>Create a new AWS IAM user <cite>circleci-scaffold-serverless</cite>, currently
with Admin privs so it can create infrastructure. Grab the creds and
paste them into the <a class="reference external" href="https://circleci.com/gh/v-studios/scaffold-serverless/edit#aws">CircleCI AWS settings for this project</a></p>
<p>Setup .circleci/config.yml to build and test, then deploy.</p>
<p>and grab the</p>
<a class="reference internal image-reference" href="_images/cicd-dashboard.png"><img alt="_images/cicd-dashboard.png" src="_images/cicd-dashboard.png" style="width: 100%;" /></a>
</div>
</div>
<span id="document-lint-flake"></span><div class="section" id="linting-with-flake8">
<h2>Linting with Flake8<a class="headerlink" href="#linting-with-flake8" title="Permalink to this headline">¶</a></h2>
<p>We use <code class="docutils literal"><span class="pre">Flake8</span> <span class="pre">&lt;http://flake8.pycqa.org/en/latest/index.html&gt;`_</span> <span class="pre">to</span>
<span class="pre">&quot;lint&quot;</span> <span class="pre">our</span> <span class="pre">code.</span> <span class="pre">Linting,</span> <span class="pre">from</span> <span class="pre">the</span> <span class="pre">``C</span></code> language, is an automatic
inspection of code that looks for sloppy technique or other suspicious
things.  It’s frequently used to enforce compliance to standard Python
coding guidelines like <a class="reference external" href="https://www.python.org/dev/peps/pep-0008/">PEP8</a>.</p>
<p>The run of Flake8 is configured by a <code class="docutils literal"><span class="pre">.flake8</span></code> file in the top
directory.  We’ve tweaked it to allow 96-character long lines instead
of the more restricive (and less readable) 72 characters PEP8
recommends; in a world of big screens, 72 decreases readability.</p>
</div>
<span id="document-git-hooks"></span><div class="section" id="git-hooks">
<h2>Git Hooks<a class="headerlink" href="#git-hooks" title="Permalink to this headline">¶</a></h2>
<p>We use a git Pre-Push hook <a class="reference external" href=".git/hooks/pre-push">.git/hooks/pre-push</a>. Unsurprisingly, it’s run right before pushing
code to the repo.  That hook does things like runs our test suite and
Flake8 lint checks.</p>
<p>If any of the tests or the flake8 process fail, the script exits with
a non-zero status and this prevents the git push from going
through. Fix your code, commit, and try again.</p>
<p>If you want to force a push, of untested, unlinted code, use the flag like:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">git</span> <span class="n">push</span> <span class="o">--</span><span class="n">no</span><span class="o">-</span><span class="n">verify</span>
</pre></div>
</div>
<p>and hang your head shame in.</p>
<p>I’ve created a build-badge for the top <code class="docutils literal"><span class="pre">README.rst</span></code>.  On the
CircleCI’s projects page hit Settings for this project then Status
Badges. Since this is a private repo, I had to crate a new token,
which I called <code class="docutils literal"><span class="pre">scaffold-serverless-build-badge</span></code>, then selected
<code class="docutils literal"><span class="pre">reStructuredText</span></code> and pasted the generated code in the README file.</p>
</div>
<span id="document-serverless-app"></span><div class="section" id="serverless-crudite">
<h2>Serverless Crudite<a class="headerlink" href="#serverless-crudite" title="Permalink to this headline">¶</a></h2>
<p>We create a sample CRUD app that should allow file upload, extraction
of simple metadata, publishing the metadata to a database, viewing and
editing the information.</p>
<p>Pick a recent Node version:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">nvm</span> <span class="n">use</span> <span class="mf">9.2</span><span class="o">.</span><span class="mi">0</span>
</pre></div>
</div>
<p>I created an initial <code class="docutils literal"><span class="pre">package.json</span></code>:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">npm</span> <span class="n">init</span>
</pre></div>
</div>
<p>then installed the Serverles framework locally:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">npm</span> <span class="n">install</span> <span class="o">--</span><span class="n">save</span> <span class="n">serverless</span>
</pre></div>
</div>
<p>Perhaps I’m using <code class="docutils literal"><span class="pre">npm</span></code> wrong but it feels dangerous doing a global
install of serverless to get the <code class="docutils literal"><span class="pre">sls</span></code> command (which is installed
in /usr/local/bin/).  Instead, we’ll have to drill into our
<code class="docutils literal"><span class="pre">node_modules</span></code> directory. Create a new <a class="reference external" href="https://serverless.com/framework/docs/providers/aws/cli-reference/create/">Serverless service</a>:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">./</span><span class="n">node_modules</span><span class="o">/</span><span class="n">serverless</span><span class="o">/</span><span class="nb">bin</span><span class="o">/</span><span class="n">serverless</span> <span class="n">create</span> <span class="o">--</span><span class="n">template</span> <span class="n">aws</span><span class="o">-</span><span class="n">python3</span> <span class="o">--</span><span class="n">path</span> <span class="n">app</span>
</pre></div>
</div>
<p>Set your AWS Profile so you can create serverless resources, this is profile name:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">export</span> <span class="n">AWS_PROFILE</span><span class="o">=</span><span class="n">vstudios</span>
</pre></div>
</div>
<p>Go into the <code class="docutils literal"><span class="pre">app</span></code> directory and deploy the sample app:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">../</span><span class="n">node_modules</span><span class="o">/</span><span class="n">serverless</span><span class="o">/</span><span class="nb">bin</span><span class="o">/</span><span class="n">serverless</span> <span class="n">deploy</span>
</pre></div>
</div>
</div>
<span id="document-stage-envs"></span><div class="section" id="stage-based-aws-environments">
<h2>Stage-based AWS Environments<a class="headerlink" href="#stage-based-aws-environments" title="Permalink to this headline">¶</a></h2>
<p>We are creating separate AWS environmets for each “stage”, like “dev”,
“qa”, and “prod”. We also create developer-specific environments that
are used for their feature branches. This allows developers freedom to
tinker without blowing away other developers’ work.</p>
<p>The AWS environment – what Serverless calls “stage” – is based on the
the <a class="reference external" href="http://nvie.com/posts/a-successful-git-branching-model/">GitFlow model</a>.
The stage name is based on the Git branch that’s being processed:</p>
<table border="1" class="docutils">
<colgroup>
<col width="22%" />
<col width="33%" />
<col width="45%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Branch</th>
<th class="head">Stage Environment</th>
<th class="head">Comment</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>(any)</td>
<td>local</td>
<td>Work on your computer only</td>
</tr>
<tr class="row-odd"><td>feature/*</td>
<td>$CIRCLE_USERNAME</td>
<td>Feature Branches build an
environment named for your
GitHub username</td>
</tr>
<tr class="row-even"><td>develop</td>
<td>dev</td>
<td>Default stage name for the
Serverless Framework</td>
</tr>
<tr class="row-odd"><td>release/*</td>
<td>qa</td>
<td>Quality Assurance checks are
done before release to
production</td>
</tr>
<tr class="row-even"><td>master</td>
<td>prod</td>
<td>The conventional name for
production systems</td>
</tr>
</tbody>
</table>
<p>Note that “master” and “develop” branches get fixed stage names “prod”
and “dev” respectively. “release/” branches use the “qa” stage
config. “feature/” branch, like
“feature/cs/VW-525_create_cicd_framework” uses a stage name based on
the $CIRCLE_USERNAME variable which is the same as the developer’s
GitHub username – in my case, “shentonfreude”.</p>
<p>Variables specific to each Serverless “stage” are in
<a class="reference external" href="stage_vars.yml">stagevars.yml</a>. In that file, we have
<code class="docutils literal"><span class="pre">.yml</span></code> sections named for each stage. Some tweaks to the
environment are done in <a class="reference external" href="serverless.yml">serverless.yml</a>, like
suffixing the stage name to S3 buckets or DynamoDB tables to ensure
uniqueness across all environments.</p>
<p>The developer-specific stage allows all developers to have their own
AWS environment and prevents one developer from breaking the work of
another. Since Serverless resources – Lambda, S3 and DynamoDB – are
very inexpensive to run, this is a minimal cost.  (If we had ELB, EC2,
and RDS resources, we might not do this due to the high cost).</p>
<p>While we expect to use CI/CD to deploy, if you want to deploy the
Serverless code manually, you should use a stage name that equals your
GitHub username. This way, you’ll have your own environment, one
that’s also used by your feature branches. Like this:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">../</span><span class="n">node_modules</span><span class="o">/</span><span class="n">serverless</span><span class="o">/</span><span class="nb">bin</span><span class="o">/</span><span class="n">serverless</span> <span class="n">deploy</span> <span class="o">--</span><span class="n">stage</span><span class="o">=</span><span class="n">shentonfreude</span> <span class="o">--</span><span class="n">verbose</span>
</pre></div>
</div>
<p>The “qa” stage, based on a “release/*” branch, allows us to continue
work on the “development” branch while we allow stake holders (e.g.,
customers) to review what we expect to deploy to production soon.</p>
</div>
<span id="document-api"></span><div class="section" id="api">
<h2>API<a class="headerlink" href="#api" title="Permalink to this headline">¶</a></h2>
<p>We’ve added an API, using <a class="reference external" href="https://aws.amazon.com/api-gateway/">API Gateway</a> so we can handle web
requests. These endpoints are defined in the serverless.yml file, and
specify the URL path, method, and handler to invoke.</p>
<div class="section" id="get-upload-url">
<h3>GET /upload_url<a class="headerlink" href="#get-upload-url" title="Permalink to this headline">¶</a></h3>
<p>Get a presigned key URL that we can use to PUT the file to do an upload.</p>
<p>Ideally we would like a web page that presents an upload form. It
would first GET a presigned URL from the API, then the browser would
directly PUT the file to that URL. This prevents tying up the API
server with potentially long and large upload files.</p>
<p>Until we have a web page and Angular code to handle the form, response
and upload, we’ll use <code class="docutils literal"><span class="pre">curl</span></code>.</p>
<p>First, find the API endpoint based on your stage:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>\<span class="o">../</span><span class="n">node_modules</span><span class="o">/.</span><span class="n">bin</span><span class="o">/</span><span class="n">sls</span> <span class="n">info</span> <span class="o">--</span><span class="n">stage</span> <span class="n">shentonfreude</span>
</pre></div>
</div>
<p>I then set a variable for the URL to make it easy to refer to:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">urlget</span><span class="o">=</span><span class="s2">&quot;https://WHATEVER.execute-api.us-east-1.amazonaws.com/shentonfreude/upload_url&quot;</span>
</pre></div>
</div>
<p>Get a presigned URL from the API, specifying the name of your file as
a querystring param:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>curl $urlget?filename=ALEX.JPG

{&quot;url&quot;: &quot;https://uploads-info-shentonfreude.s3.amazonaws.com/ALEX.JPG?AWSAccessKeyId=...&quot;}
</pre></div>
</div>
<p>Set a variable to that long URL for convenience:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">url</span><span class="o">=</span><span class="s2">&quot;https://uploads-info-shentonfreude.s3.amazonaws.com/ALEX.JPG?AWSAccessKeyId=...&quot;</span>
</pre></div>
</div>
<p>Then PUT a file to that URL:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>curl -i --upload-file ~/Pictures/alex.jpg $url
</pre></div>
</div>
<div class="section" id="serverless-yml">
<h4>serverless.yml<a class="headerlink" href="#serverless-yml" title="Permalink to this headline">¶</a></h4>
<p>We define the function and handler together:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">getUploadPSK</span><span class="p">:</span>
<span class="n">handler</span><span class="p">:</span> <span class="n">handler</span><span class="o">.</span><span class="n">get_upload_url</span>
<span class="n">events</span><span class="p">:</span>
  <span class="o">-</span> <span class="n">http</span><span class="p">:</span> <span class="n">GET</span> <span class="o">/</span><span class="n">upload_url</span>
</pre></div>
</div>
<p>The Lambda must be given permissions for the presigned URL to allow the upload:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>iamRoleStatements:
  - Effect: Allow
    Resource: arn:aws:s3:::uploads-info-${self:provider.stage}/*
    Action:
      - s3:PutObject
      - s3:PutObjectAcl
      - s3:PutObjectTagging
</pre></div>
</div>
</div>
</div>
<div class="section" id="get-assets">
<h3>GET /assets<a class="headerlink" href="#get-assets" title="Permalink to this headline">¶</a></h3>
<p>Return info about the assets from the DynamoDB table, as JSON or if
‘text/html’ is in the request’s Accept header, as HTML.</p>
<p>It’s naive and just does a table scan, which is expensive and stupid
but will be OK for this toy demo (unless we get a lot of items).</p>
<p>I had to fight with DynamoDB to turn numerics returned by boto3
as <code class="docutils literal"><span class="pre">decimal.Decimal</span></code> types into plain old <code class="docutils literal"><span class="pre">int</span></code> so JSON could
render them.</p>
<div class="section" id="id1">
<h4>serverless.yml<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h4>
<p>The endpoint is specified in <code class="docutils literal"><span class="pre">serverless.yml</span></code> and we don’t have any
new permissions to add:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">getAssets</span><span class="p">:</span>                    <span class="c1"># JSON, or HTML if &quot;Accepts: text/html&quot;</span>
  <span class="n">handler</span><span class="p">:</span> <span class="n">handler</span><span class="o">.</span><span class="n">get_assets</span>
  <span class="n">events</span><span class="p">:</span>
    <span class="o">-</span> <span class="n">http</span><span class="p">:</span>  <span class="n">GET</span> <span class="o">/</span><span class="n">assets</span>
</pre></div>
</div>
</div>
</div>
</div>
<span id="document-todo"></span><div class="section" id="todo">
<h2>TODO<a class="headerlink" href="#todo" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li>Add our source code directories to the coverage report (it does <code class="docutils literal"><span class="pre">.</span></code> now, which is useless)</li>
<li>separate requirements-devel.rst</li>
<li>Try and prevent pip from reinstalling everything on every run, figure out the dependecy detection</li>
<li>accept form fields like: “curl –form filename=ALEX.JPG”; may have to do with a POST Lambda handler</li>
</ul>
</div>
</div>
</div>
<div class="section" id="indices-and-tables">
<h1>Indices and tables<a class="headerlink" href="#indices-and-tables" title="Permalink to this headline">¶</a></h1>
<ul class="simple">
<li><a class="reference internal" href="genindex.html"><span class="std std-ref">Index</span></a></li>
<li><a class="reference internal" href="py-modindex.html"><span class="std std-ref">Module Index</span></a></li>
<li><a class="reference internal" href="search.html"><span class="std std-ref">Search Page</span></a></li>
</ul>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper"><div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="index.html#document-index">Documentation overview</a><ul>
  </ul></li>
</ul>
</div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2018, Chris Shenton.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.6.7</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.10</a>
      
    </div>

    

    
  </body>
</html>